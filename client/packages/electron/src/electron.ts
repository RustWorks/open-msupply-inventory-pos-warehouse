import { app, BrowserWindow, ipcMain } from 'electron';
import startDiscovery from 'multicast-dns';
import { IPC_MESSAGES } from './shared';
import ip from 'ip';
import {
  FrontEndHost,
  frontEndHostUrl,
} from '@openmsupply-client/common/src/hooks/useElectronClient';
import storage from 'electron-data-storage';
import HID from 'node-hid';

const QUERY_INTERVAL = 1000;
const SERVICE_NAME = '_omsupply._tcp.local';
const SERVICE_TYPE = 'TXT';
const SUPPORTED_SCANNERS = [
  {
    vendorId: 1504,
    vendorName: 'Zebra',
    products: [{ id: 2194, model: 'DS2208' }],
  },
];

class DiscoveryRunner {
  intervalHandle?: NodeJS.Timer;

  start() {
    this.intervalHandle = setInterval(() => {
      discovery.query({
        questions: [
          {
            name: SERVICE_NAME,
            type: SERVICE_TYPE,
          },
        ],
      });
    }, QUERY_INTERVAL);
  }

  stop() {
    if (this.intervalHandle) clearInterval(this.intervalHandle);
    this.intervalHandle = undefined;
  }
}

class BarcodeScanner {
  device: HID.HID | undefined;

  constructor() {
    this.findDevice();
  }

  findDevice() {
    const devices = HID.devices();
    for (const scanner of SUPPORTED_SCANNERS) {
      const productIds = scanner.products.map(p => p.id);
      const deviceInfo = devices.find(d => {
        d.vendorId === scanner.vendorId &&
          productIds.some(pid => d.productId === pid);
      });
      if (deviceInfo && !!deviceInfo.path) {
        this.device = new HID.HID(deviceInfo.path);
        break;
      }
    }
  }

  start() {
    return new Promise((resolve, reject) => {
      this.device?.read((err, data) => {
        if (err) reject(err);
        resolve(data);
      });
    });
  }

  stop() {
    this.device?.close();
    this.findDevice();
  }
}

const discovery = startDiscovery();
const discoverRunner = new DiscoveryRunner();
const barcodeScanner = new BarcodeScanner();

let connectedServer: FrontEndHost | null = null;

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const connectToServer = (window: BrowserWindow, server: FrontEndHost) => {
  discoverRunner.stop();
  const { ELECTRON_HOST } = process.env;
  const url =
    (typeof ELECTRON_HOST !== 'undefined' && ELECTRON_HOST) ||
    frontEndHostUrl(server);
  window.loadURL(url);
  connectedServer = server;
  storage.set('/mru/server', url);
  discovery.destroy();
};

const start = (): void => {
  // Create the browser window.
  const window = new BrowserWindow({
    height: 768,
    width: 1024,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });
  // and load the index.html of the app.
  window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // allow the user to press Alt and force display of the server selection
  window.webContents.on('before-input-event', (event, input) => {
    if (input.alt) {
      storage.remove('/mru/server');
      event.preventDefault();
    }
  });

  ipcMain.on(IPC_MESSAGES.START_SERVER_DISCOVERY, () => discoverRunner.start());

  ipcMain.on(IPC_MESSAGES.CONNECT_TO_SERVER, (_event, server: FrontEndHost) =>
    connectToServer(window, server)
  );

  ipcMain.handle(IPC_MESSAGES.CONNECTED_SERVER, async () => connectedServer);
  ipcMain.handle(IPC_MESSAGES.START_BARCODE_SCAN, () => barcodeScanner.start());
  ipcMain.on(IPC_MESSAGES.STOP_BARCODE_SCAN, () => barcodeScanner.stop());

  discovery.on('response', function ({ answers }) {
    const answer = answers[0];
    if (!answer) return;
    if (answer.name !== SERVICE_NAME) return;
    if (answer.type !== SERVICE_TYPE) return;
    const server: FrontEndHost = JSON.parse(answer.data.toString());
    // the IP is showing as 127.0.0.1 for local servers when running on windows
    server.isLocal = server.ip === ip.address() || server.ip === '127.0.0.1';

    const mruServer = storage.get('/mru/server');
    // if there is a recent server.. and we have found it - no need to display the server selection
    // simply connect to it. Otherwise.. the server should be displayed.
    if (mruServer && mruServer === frontEndHostUrl(server)) {
      connectToServer(window, server);
    } else {
      window.webContents.send(IPC_MESSAGES.SERVER_DISCOVERED, server);
    }
  });
};

app.on('ready', start);

app.on('window-all-closed', () => {
  app.quit();
});

app.on(
  'certificate-error',
  (event, _webContents, url, _error, _certificate, callback) => {
    if (!connectedServer) return callback(false);

    if (url.startsWith(frontEndHostUrl(connectedServer))) {
      event.preventDefault();
      callback(true);
    } else {
      callback(false);
    }
  }
);
