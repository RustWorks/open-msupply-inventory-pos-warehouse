# Queries must match the schema.graphql file, see readme.md test section.

# INSERT SUPPLIER INVOICE

mutation insertSupplierInvoiceFull(
  $id: String!
  $otherPartyId: String!
  $status: InvoiceNodeStatus!
  $comment_option: String
  $theirReference_option: String
) {
  insertSupplierInvoice(
    input: {
      id: $id
      otherPartyId: $otherPartyId
      status: $status
      theirReference: $theirReference_option
      comment: $comment_option
    }
  ) {
    ...InsertSupplierInvoiceResponse
  }
}

fragment InsertSupplierInvoiceResponse on InsertSupplierInvoiceResponse {
  __typename
  ...InsertSupplierInvoiceError
  ...NodeError
  ...InvoiceNode
}

fragment InsertSupplierInvoiceError on InsertSupplierInvoiceError {
  error {
    ...InsertSupplierInvoiceErrorInterface
  }
}

fragment InsertSupplierInvoiceErrorInterface on InsertSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...ForeignKeyError
  ...OtherPartyNotASupplier
  ...RecordAlreadyExist
}

# UPDATE SUPPLIER INVOICE

mutation updateSupplierInvoiceFull(
  $id: String!
  $otherPartyId_option: String
  $status_option: InvoiceNodeStatus
  $comment_option: String
  $theirReference_option: String
) {
  updateSupplierInvoice(
    input: {
      id: $id
      otherPartyId: $otherPartyId_option
      status: $status_option
      theirReference: $theirReference_option
      comment: $comment_option
    }
  ) {
    ...UpdateSupplierInvoiceResponse
  }
}

fragment UpdateSupplierInvoiceResponse on UpdateSupplierInvoiceResponse {
  __typename
  ...UpdateSupplierInvoiceError
  ...NodeError
  ...InvoiceNode
}

fragment UpdateSupplierInvoiceError on UpdateSupplierInvoiceError {
  error {
    ...UpdateSupplierInvoiceErrorInterface
  }
}

fragment UpdateSupplierInvoiceErrorInterface on UpdateSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...ForeignKeyError
  ...OtherPartyNotASupplier
  ...RecordDoesNotExist
  ...CannotEditFinalisedInvoice
  ...NotASupplierInvoice
  ...InvoiceDoesNotBelongToCurrentStore
  ...CannotChangeInvoiceBackToDraft
}

# DELETE SUPPLIER INVOICE

mutation deleteSupplierInvoiceFull($id: String!) {
  deleteSupplierInvoice(input: { id: $id }) {
    ...DeleteSupplierInvoiceResponse
  }
}

fragment DeleteSupplierInvoiceResponse on DeleteSupplierInvoiceResponse {
  __typename
  ...DeleteSupplierInvoiceError
  ...DeleteResponse
}

fragment DeleteSupplierInvoiceError on DeleteSupplierInvoiceError {
  error {
    ...DeleteSupplierInvoiceErrorInterface
  }
}

fragment DeleteSupplierInvoiceErrorInterface on DeleteSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...RecordDoesNotExist
  ...CannotEditFinalisedInvoice
  ...NotASupplierInvoice
  ...InvoiceDoesNotBelongToCurrentStore
  ...CannotDeleteInvoiceWithLines
}

# INSERT SUPPLIER INVOICE LINE

mutation insertSupplierInvoiceLineFull(
  $batch_option: String
  $costPricePerPack: Float!
  $expiryDate_option: NaiveDate
  $id: String!
  $invoiceId: String!
  $itemId: String!
  $numberOfPacks: Int!
  $sellPricePerPack: Float!
  $packSize: Int!
) {
  insertSupplierInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId
      itemId: $itemId
      packSize: $packSize
      costPricePerPack: $costPricePerPack
      sellPricePerPack: $sellPricePerPack
      numberOfPacks: $numberOfPacks
      expiryDate: $expiryDate_option
      batch: $batch_option
      packSize: $packSize
    }
  ) {
    ...InsertSupplierInvoiceLineResponse
  }
}

fragment InsertSupplierInvoiceLineResponse on InsertSupplierInvoiceLineResponse {
  __typename
  ...InsertSupplierInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment InsertSupplierInvoiceLineError on InsertSupplierInvoiceLineError {
  error {
    ...InsertSupplierInvoiceLineErrorInterface
  }
}

fragment InsertSupplierInvoiceLineErrorInterface on InsertSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RangeError
  ...RecordAlreadyExist
}

# UPDATES SUPPLIER INVOICE LINE

mutation updateSupplierInvoiceLineFull(
  $batch_option: String
  $costPricePerPack_option: Float
  $expiryDate_option: NaiveDate
  $id: String!
  $invoiceId: String!
  $itemId_option: String
  $numberOfPacks_option: Int
  $sellPricePerPack_option: Float
  $packSize_option: Int
) {
  updateSupplierInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId
      itemId: $itemId_option
      packSize: $packSize_option
      costPricePerPack: $costPricePerPack_option
      sellPricePerPack: $sellPricePerPack_option
      numberOfPacks: $numberOfPacks_option
      expiryDate: $expiryDate_option
      batch: $batch_option
      packSize: $packSize_option
    }
  ) {
    ...UpdateSupplierInvoiceLineResponse
  }
}

fragment UpdateSupplierInvoiceLineResponse on UpdateSupplierInvoiceLineResponse {
  __typename
  ...UpdateSupplierInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment UpdateSupplierInvoiceLineError on UpdateSupplierInvoiceLineError {
  error {
    ...UpdateSupplierInvoiceLineErrorInterface
  }
}

fragment UpdateSupplierInvoiceLineErrorInterface on UpdateSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RangeError
  ...RecordDoesNotExist
  ...BatchIsReserved
  ...InvoiceLineBelongsToAnotherInvoice
}

# UPDATES CUSTOMER INVOICE LINE

mutation updateCustomerInvoiceLineFull(
  $id: String!
  $invoiceId: String!
  $itemId_option: String
  $numberOfPacks_option: Int
  $stockLineId_option: String
) {
  updateCustomerInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId
      itemId: $itemId_option
      numberOfPacks: $numberOfPacks_option
      stockLineId: $stockLineId_option
    }
  ) {
    ...UpdateCustomerInvoiceLineResponse
  }
}

fragment UpdateCustomerInvoiceLineResponse on UpdateCustomerInvoiceLineResponse {
  __typename
  ...UpdateCustomerInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment UpdateCustomerInvoiceLineError on UpdateCustomerInvoiceLineError {
  error {
    ...UpdateCustomerInvoiceLineErrorInterface
  }
}

fragment UpdateCustomerInvoiceLineErrorInterface on UpdateCustomerInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...InvoiceLineBelongsToAnotherInvoice
  ...LineDoesNotReferenceStockLine
  ...NotACustomerInvoice
  ...NotEnoughStockForReduction
  ...RangeError
  ...RecordDoesNotExist
  ...StockLineAlreadyExistsInInvoice
  ...StockLineDoesNotBelongToCurrentStore
  ...ItemDoesNotMatchStockLine
}

# INSERTS CUSTOMER INVOICE LINE

mutation insertCustomerInvoiceLineFull(
  $id: String!
  $invoiceId: String!
  $itemId: String!
  $numberOfPacks: Int!
  $stockLineId: String!
) {
  insertCustomerInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId
      itemId: $itemId
      numberOfPacks: $numberOfPacks
      stockLineId: $stockLineId
    }
  ) {
    ...InsertCustomerInvoiceLineResponse
  }
}

fragment InsertCustomerInvoiceLineResponse on InsertCustomerInvoiceLineResponse {
  __typename
  ...InsertCustomerInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment InsertCustomerInvoiceLineError on InsertCustomerInvoiceLineError {
  error {
    ...InsertCustomerInvoiceLineErrorInterface
  }
}

fragment InsertCustomerInvoiceLineErrorInterface on InsertCustomerInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...ItemDoesNotMatchStockLine
  ...NotACustomerInvoice
  ...NotEnoughStockForReduction
  ...RangeError
  ...RecordAlreadyExist
  ...StockLineAlreadyExistsInInvoice
  ...StockLineDoesNotBelongToCurrentStore
}

# DELETE SUPPLIER INVOICE LINE

mutation deleteSupplierInvoiceLineFull($id: String!, $invoiceId: String!) {
  deleteSupplierInvoiceLine(input: { id: $id, invoiceId: $invoiceId }) {
    ...DeleteSupplierInvoiceLineResponse
  }
}

fragment DeleteSupplierInvoiceLineResponse on DeleteSupplierInvoiceLineResponse {
  __typename
  ...DeleteSupplierInvoiceLineError
  ...DeleteResponse
}

fragment DeleteSupplierInvoiceLineError on DeleteSupplierInvoiceLineError {
  error {
    ...DeleteSupplierInvoiceLineErrorInterface
  }
}

fragment DeleteSupplierInvoiceLineErrorInterface on DeleteSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RecordDoesNotExist
  ...BatchIsReserved
  ...InvoiceLineBelongsToAnotherInvoice
}

# DELETE CUSTOMER INVOICE LINE

mutation deleteCustomerInvoiceLineFull($id: String!, $invoiceId: String!) {
  deleteCustomerInvoiceLine(input: { id: $id, invoiceId: $invoiceId }) {
    ...DeleteCustomerInvoiceLineResponse
  }
}

fragment DeleteCustomerInvoiceLineResponse on DeleteCustomerInvoiceLineResponse {
  __typename
  ...DeleteCustomerInvoiceLineError
  ...DeleteResponse
}

fragment DeleteCustomerInvoiceLineError on DeleteCustomerInvoiceLineError {
  error {
    ...DeleteCustomerInvoiceLineErrorInterface
  }
}

fragment DeleteCustomerInvoiceLineErrorInterface on DeleteCustomerInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotACustomerInvoice
  ...RecordDoesNotExist
  ...InvoiceLineBelongsToAnotherInvoice
}

# INVOICE

query invoiceFull($id: String!) {
  invoice(id: $id) {
    ...InvoiceResponse
  }
}

fragment InvoiceResponse on InvoiceResponse {
  __typename
  ...InvoiceNode
  ...NodeError
}

fragment InvoiceNode on InvoiceNode {
  comment
  confirmedDatetime
  entryDatetime
  finalisedDatetime
  id
  invoiceNumber
  lines {
    ...InvoiceLinesResponse
  }
  otherPartyId
  otherPartyName
  pricing {
    ...InvoicePriceResponse
  }
  status
  theirReference
  type
}

fragment InvoicePriceResponse on InvoicePriceResponse {
  __typename
  ...NodeError
  ...InvoicePricingNode
}

fragment InvoicePricingNode on InvoicePricingNode {
  totalAfterTax
}

# INVOICE LINE

fragment InvoiceLineResponse on InvoiceLineResponse {
  __typename
  ...NodeError
  ...InvoiceLineNode
}

fragment InvoiceLinesResponse on InvoiceLinesResponse {
  __typename
  ...ConnectorError
  ...InvoiceLineConnector
}

fragment InvoiceLineNode on InvoiceLineNode {
  batch
  costPricePerPack
  expiryDate
  id
  itemCode
  itemId
  itemName
  numberOfPacks
  packSize
  sellPricePerPack
  stockLine {
    ...StockLineResponse
  }
}

fragment InvoiceLineConnector on InvoiceLineConnector {
  totalCount
  nodes {
    ...InvoiceLineNode
  }
}

# STOCK LINE

fragment StockLineResponse on StockLineResponse {
  __typename
  ...NodeError
  ...StockLineNode
}

fragment StockLineNode on StockLineNode {
  id
  availableNumberOfPacks
  batch
  costPricePerPack
  expiryDate
  itemId
  packSize
  sellPricePerPack
  storeId
  totalNumberOfPacks
}

# NAME

fragment NameNode on NameNode {
  code
  id
  isCustomer
  isSupplier
  name
}

# COMMON

fragment DeleteResponse on DeleteResponse {
  id
}

# ERRORS

fragment RecordAlreadyExist on RecordAlreadyExist {
  description
}

fragment RecordDoesNotExist on RecordDoesNotExist {
  description
}

fragment ForeignKeyError on ForeignKeyError {
  description
  key
}

fragment DatabaseError on DatabaseError {
  description
  fullError
}

fragment OtherPartyNotASupplier on OtherPartyNotASupplier {
  description
  otherParty {
    ...NameNode
  }
}

fragment RecordNotFound on RecordNotFound {
  id
  description
}

fragment NodeError on NodeError {
  error {
    ...NodeErrorInterface
  }
}

fragment NodeErrorInterface on NodeErrorInterface {
  __typename
  ...DatabaseError
  ...RecordNotFound
}

fragment PaginationError on PaginationError {
  description
  rangeError {
    ...RangeError
  }
}

fragment RangeError on RangeError {
  description
  field
  max
  min
}

fragment ConnectorError on ConnectorError {
  error {
    ...ConnectorErrorInterface
  }
}

fragment ConnectorErrorInterface on ConnectorErrorInterface {
  __typename
  ...DatabaseError
  ...PaginationError
}

fragment CannotEditFinalisedInvoice on CannotEditFinalisedInvoice {
  description
}

fragment NotASupplierInvoice on NotASupplierInvoice {
  description
}

fragment NotACustomerInvoice on NotACustomerInvoice {
  description
}

fragment InvoiceDoesNotBelongToCurrentStore on InvoiceDoesNotBelongToCurrentStore {
  description
}

fragment CannotChangeInvoiceBackToDraft on CannotChangeInvoiceBackToDraft {
  description
}

fragment CannotDeleteInvoiceWithLines on CannotDeleteInvoiceWithLines {
  description
  lines {
    ...InvoiceLineConnector
  }
}

fragment BatchIsReserved on BatchIsReserved {
  description
}

fragment StockLineDoesNotBelongToCurrentStore on StockLineDoesNotBelongToCurrentStore {
  description
}

fragment ItemDoesNotMatchStockLine on ItemDoesNotMatchStockLine {
  description
}

fragment LineDoesNotReferenceStockLine on LineDoesNotReferenceStockLine {
  description
}

fragment StockLineAlreadyExistsInInvoice on StockLineAlreadyExistsInInvoice {
  description
  line {
    ...InvoiceLineResponse
  }
}

fragment NotEnoughStockForReduction on NotEnoughStockForReduction {
  description
  batch {
    ...StockLineResponse
  }
  line {
    ...InvoiceLineResponse
  }
}

fragment InvoiceLineBelongsToAnotherInvoice on InvoiceLineBelongsToAnotherInvoice {
  description
  invoice {
    ...InvoiceResponse
  }
}
