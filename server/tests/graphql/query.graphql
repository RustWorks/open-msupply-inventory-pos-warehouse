# Queries must match the schema.graphql file, see readme.md test section.

# INSERT SUPPLIER INVOICE

mutation insertSupplierInvoiceFull(
  $id: String!
  $otherPartyId_isi: String!
  $status_isi: InvoiceNodeStatus!
  $comment_isi: String
  $theirReference_isi: String
) {
  insertSupplierInvoice(
    input: {
      id: $id
      otherPartyId: $otherPartyId_isi
      status: $status_isi
      theirReference: $theirReference_isi
      comment: $comment_isi
    }
  ) {
    ...InsertSupplierInvoiceResponse
  }
}

fragment InsertSupplierInvoiceResponse on InsertSupplierInvoiceResponse {
  __typename
  ...InsertSupplierInvoiceError
  ...NodeError
  ...InvoiceNode
}

fragment InsertSupplierInvoiceError on InsertSupplierInvoiceError {
  error {
    ...InsertSupplierInvoiceErrorInterface
  }
}

fragment InsertSupplierInvoiceErrorInterface on InsertSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...ForeignKeyError
  ...OtherPartyNotASupplier
  ...RecordAlreadyExist
}

# UPDATE SUPPLIER INVOICE

mutation updateSupplierInvoiceFull(
  $id: String!
  $otherPartyId_usi: String
  $status_usi: InvoiceNodeStatus
  $comment_usi: String
  $theirReference_usi: String
) {
  updateSupplierInvoice(
    input: {
      id: $id
      otherPartyId: $otherPartyId_usi
      status: $status_usi
      theirReference: $theirReference_usi
      comment: $comment_usi
    }
  ) {
    ...UpdateSupplierInvoiceResponse
  }
}

fragment UpdateSupplierInvoiceResponse on UpdateSupplierInvoiceResponse {
  __typename
  ...UpdateSupplierInvoiceError
  ...NodeError
  ...InvoiceNode
}

fragment UpdateSupplierInvoiceError on UpdateSupplierInvoiceError {
  error {
    ...UpdateSupplierInvoiceErrorInterface
  }
}

fragment UpdateSupplierInvoiceErrorInterface on UpdateSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...ForeignKeyError
  ...OtherPartyNotASupplier
  ...RecordDoesNotExist
  ...CannotEditFinalisedInvoice
  ...NotASupplierInvoice
  ...InvoiceDoesNotBelongToCurrentStore
  ...CannotChangeInvoiceBackToDraft
}

# DELETE SUPPLIER INVOICE

mutation deleteSupplierInvoiceFull($id: String!) {
  deleteSupplierInvoice(input: { id: $id }) {
    ...DeleteSupplierInvoiceResponse
  }
}

fragment DeleteSupplierInvoiceResponse on DeleteSupplierInvoiceResponse {
  __typename
  ...DeleteSupplierInvoiceError
  ...DeleteResponse
}

fragment DeleteSupplierInvoiceError on DeleteSupplierInvoiceError {
  error {
    ...DeleteSupplierInvoiceErrorInterface
  }
}

fragment DeleteSupplierInvoiceErrorInterface on DeleteSupplierInvoiceErrorInterface {
  __typename
  ...DatabaseError
  ...RecordDoesNotExist
  ...CannotEditFinalisedInvoice
  ...NotASupplierInvoice
  ...InvoiceDoesNotBelongToCurrentStore
  ...CannotDeleteInvoiceWithLines
}

# INSERT SUPPLIER INVOICE LINE

mutation insertSupplierInvoiceLineFull(
  $batch_isil: String
  $costPricePerPack_isil: Float!
  $expiryDate_isil: NaiveDate
  $id: String!
  $invoiceId_isil: String!
  $itemId_isil: String!
  $numberOfPacks_isil: Int!
  $sellPricePerPack_isil: Float!
  $packSize_isil: Int!
) {
  insertSupplierInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId_isil
      itemId: $itemId_isil
      packSize: $packSize_isil
      costPricePerPack: $costPricePerPack_isil
      sellPricePerPack: $sellPricePerPack_isil
      numberOfPacks: $numberOfPacks_isil
      expiryDate: $expiryDate_isil
      batch: $batch_isil
      packSize: $packSize_isil
    }
  ) {
    ...InsertSupplierInvoiceLineResponse
  }
}

fragment InsertSupplierInvoiceLineResponse on InsertSupplierInvoiceLineResponse {
  __typename
  ...InsertSupplierInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment InsertSupplierInvoiceLineError on InsertSupplierInvoiceLineError {
  error {
    ...InsertSupplierInvoiceLineErrorInterface
  }
}

fragment InsertSupplierInvoiceLineErrorInterface on InsertSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RangeError
  ...RecordAlreadyExist
}

# UPDATES SUPPLIER INVOICE LINE

mutation updateSupplierInvoiceLineFull(
  $batch_usil: String
  $costPricePerPack_usil: Float
  $expiryDate_usil: NaiveDate
  $id: String!
  $invoiceId_usil: String!
  $itemId_usil: String
  $numberOfPacks_usil: Int
  $sellPricePerPack_usil: Float
  $packSize_usil: Int
) {
  updateSupplierInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId_usil
      itemId: $itemId_usil
      packSize: $packSize_usil
      costPricePerPack: $costPricePerPack_usil
      sellPricePerPack: $sellPricePerPack_usil
      numberOfPacks: $numberOfPacks_usil
      expiryDate: $expiryDate_usil
      batch: $batch_usil
      packSize: $packSize_usil
    }
  ) {
    ...UpdateSupplierInvoiceLineResponse
  }
}

fragment UpdateSupplierInvoiceLineResponse on UpdateSupplierInvoiceLineResponse {
  __typename
  ...UpdateSupplierInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment UpdateSupplierInvoiceLineError on UpdateSupplierInvoiceLineError {
  error {
    ...UpdateSupplierInvoiceLineErrorInterface
  }
}

fragment UpdateSupplierInvoiceLineErrorInterface on UpdateSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RangeError
  ...RecordDoesNotExist
  ...BatchIsReserved
  ...InvoiceLineBelongsToAnotherInvoice
}

# UPDATES CUSTOMER INVOICE LINE

mutation updateCustomerInvoiceLineFull(
  $id: String!
  $invoiceId_ucil: String!
  $itemId_ucil: String
  $numberOfPacks_ucil: Int
  $stockLineId_ucil: String
) {
  updateCustomerInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId_ucil
      itemId: $itemId_ucil
      numberOfPacks: $numberOfPacks_ucil
      stockLineId: $stockLineId_ucil
    }
  ) {
    ...UpdateCustomerInvoiceLineResponse
  }
}

fragment UpdateCustomerInvoiceLineResponse on UpdateCustomerInvoiceLineResponse {
  __typename
  ...UpdateCustomerInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment UpdateCustomerInvoiceLineError on UpdateCustomerInvoiceLineError {
  error {
    ...UpdateCustomerInvoiceLineErrorInterface
  }
}

fragment UpdateCustomerInvoiceLineErrorInterface on UpdateCustomerInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...InvoiceLineBelongsToAnotherInvoice
  ...LineDoesNotReferenceStockLine
  ...NotACustomerInvoice
  ...NotEnoughStockForReduction
  ...RangeError
  ...RecordDoesNotExist
  ...StockLineAlreadyExistsInInvoice
  ...StockLineDoesNotBelongToCurrentStore
  ...ItemDoesNotMatchStockLine
}

# INSERTS CUSTOMER INVOICE LINE

mutation insertCustomerInvoiceLineFull(
  $id: String!
  $invoiceId_icil: String!
  $itemId_icil: String!
  $numberOfPacks_icil: Int!
  $stockLineId_icil: String!
) {
  insertCustomerInvoiceLine(
    input: {
      id: $id
      invoiceId: $invoiceId_icil
      itemId: $itemId_icil
      numberOfPacks: $numberOfPacks_icil
      stockLineId: $stockLineId_icil
    }
  ) {
    ...InsertCustomerInvoiceLineResponse
  }
}

fragment InsertCustomerInvoiceLineResponse on InsertCustomerInvoiceLineResponse {
  __typename
  ...InsertCustomerInvoiceLineError
  ...NodeError
  ...InvoiceLineNode
}

fragment InsertCustomerInvoiceLineError on InsertCustomerInvoiceLineError {
  error {
    ...InsertCustomerInvoiceLineErrorInterface
  }
}

fragment InsertCustomerInvoiceLineErrorInterface on InsertCustomerInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...ItemDoesNotMatchStockLine
  ...NotACustomerInvoice
  ...NotEnoughStockForReduction
  ...RangeError
  ...RecordAlreadyExist
  ...StockLineAlreadyExistsInInvoice
  ...StockLineDoesNotBelongToCurrentStore
}

# DELETE SUPPLIER INVOICE LINE

mutation deleteSupplierInvoiceLineFull($id: String!, $invoiceId_dsil: String!) {
  deleteSupplierInvoiceLine(input: { id: $id, invoiceId: $invoiceId_dsil }) {
    ...DeleteSupplierInvoiceLineResponse
  }
}

fragment DeleteSupplierInvoiceLineResponse on DeleteSupplierInvoiceLineResponse {
  __typename
  ...DeleteSupplierInvoiceLineError
  ...DeleteResponse
}

fragment DeleteSupplierInvoiceLineError on DeleteSupplierInvoiceLineError {
  error {
    ...DeleteSupplierInvoiceLineErrorInterface
  }
}

fragment DeleteSupplierInvoiceLineErrorInterface on DeleteSupplierInvoiceLineErrorInterface {
  __typename
  ...CannotEditFinalisedInvoice
  ...DatabaseError
  ...ForeignKeyError
  ...InvoiceDoesNotBelongToCurrentStore
  ...NotASupplierInvoice
  ...RecordDoesNotExist
  ...BatchIsReserved
  ...InvoiceLineBelongsToAnotherInvoice
}

# INVOICE

query invoiceFull($id: String!) {
  invoice(id: $id) {
    ...InvoiceResponse
  }
}

fragment InvoiceResponse on InvoiceResponse {
  __typename
  ...InvoiceNode
  ...NodeError
}

fragment InvoiceNode on InvoiceNode {
  comment
  confirmedDatetime
  entryDatetime
  finalisedDatetime
  id
  invoiceNumber
  lines {
    ...InvoiceLinesResponse
  }
  otherPartyId
  otherPartyName
  pricing {
    ...InvoicePriceResponse
  }
  status
  theirReference
  type
}

fragment InvoicePriceResponse on InvoicePriceResponse {
  __typename
  ...NodeError
  ...InvoicePricingNode
}

fragment InvoicePricingNode on InvoicePricingNode {
  totalAfterTax
}

# INVOICE LINE

fragment InvoiceLineResponse on InvoiceLineResponse {
  __typename
  ...NodeError
  ...InvoiceLineNode
}

fragment InvoiceLinesResponse on InvoiceLinesResponse {
  __typename
  ...ConnectorError
  ...InvoiceLineConnector
}

fragment InvoiceLineNode on InvoiceLineNode {
  batch
  costPricePerPack
  expiryDate
  id
  itemCode
  itemId
  itemName
  numberOfPacks
  packSize
  sellPricePerPack
  stockLine {
    ...StockLineResponse
  }
}

fragment InvoiceLineConnector on InvoiceLineConnector {
  totalCount
  nodes {
    ...InvoiceLineNode
  }
}

# STOCK LINE

fragment StockLineResponse on StockLineResponse {
  __typename
  ...NodeError
  ...StockLineNode
}

fragment StockLineNode on StockLineNode {
  id
  availableNumberOfPacks
  batch
  costPricePerPack
  expiryDate
  itemId
  packSize
  sellPricePerPack
  storeId
  totalNumberOfPacks
}

# NAME

fragment NameNode on NameNode {
  code
  id
  isCustomer
  isSupplier
  name
}

# COMMON

fragment DeleteResponse on DeleteResponse {
  id
}

# ERRORS

fragment RecordAlreadyExist on RecordAlreadyExist {
  description
}

fragment RecordDoesNotExist on RecordDoesNotExist {
  description
}

fragment ForeignKeyError on ForeignKeyError {
  description
  key
}

fragment DatabaseError on DatabaseError {
  description
  fullError
}

fragment OtherPartyNotASupplier on OtherPartyNotASupplier {
  description
  otherParty {
    ...NameNode
  }
}

fragment RecordNotFound on RecordNotFound {
  id
  description
}

fragment NodeError on NodeError {
  error {
    ...NodeErrorInterface
  }
}

fragment NodeErrorInterface on NodeErrorInterface {
  __typename
  ...DatabaseError
  ...RecordNotFound
}

fragment PaginationError on PaginationError {
  description
  rangeError {
    ...RangeError
  }
}

fragment RangeError on RangeError {
  description
  field
  max
  min
}

fragment ConnectorError on ConnectorError {
  error {
    ...ConnectorErrorInterface
  }
}

fragment ConnectorErrorInterface on ConnectorErrorInterface {
  __typename
  ...DatabaseError
  ...PaginationError
}

fragment CannotEditFinalisedInvoice on CannotEditFinalisedInvoice {
  description
}

fragment NotASupplierInvoice on NotASupplierInvoice {
  description
}

fragment NotACustomerInvoice on NotACustomerInvoice {
  description
}

fragment InvoiceDoesNotBelongToCurrentStore on InvoiceDoesNotBelongToCurrentStore {
  description
}

fragment CannotChangeInvoiceBackToDraft on CannotChangeInvoiceBackToDraft {
  description
}

fragment CannotDeleteInvoiceWithLines on CannotDeleteInvoiceWithLines {
  description
  lines {
    ...InvoiceLineConnector
  }
}

fragment BatchIsReserved on BatchIsReserved {
  description
}

fragment StockLineDoesNotBelongToCurrentStore on StockLineDoesNotBelongToCurrentStore {
  description
}

fragment ItemDoesNotMatchStockLine on ItemDoesNotMatchStockLine {
  description
}

fragment LineDoesNotReferenceStockLine on LineDoesNotReferenceStockLine {
  description
}

fragment StockLineAlreadyExistsInInvoice on StockLineAlreadyExistsInInvoice {
  description
  line {
    ...InvoiceLineResponse
  }
}

fragment NotEnoughStockForReduction on NotEnoughStockForReduction {
  description
  batch {
    ...StockLineResponse
  }
  line {
    ...InvoiceLineResponse
  }
}

fragment InvoiceLineBelongsToAnotherInvoice on InvoiceLineBelongsToAnotherInvoice {
  description
  invoice {
    ...InvoiceResponse
  }
}
